{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "33a20085_c42c40cc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 11628
      },
      "writtenOn": "2023-12-06T21:16:59Z",
      "side": 1,
      "message": "The lib/apache code change has been tested with a related Octavia code change and succeeded.",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a695ba5d_087fc8be",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 11604
      },
      "writtenOn": "2024-03-05T16:41:42Z",
      "side": 1,
      "message": "we are likely to merge the nova patch this week. this looks correct to me based on the ci results",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "141c427b_1535b2ad",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 22873
      },
      "writtenOn": "2024-04-19T10:56:45Z",
      "side": 1,
      "message": "lgtm, thanks",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ef863c04_e6bf2cf4",
        "filename": "lib/apache",
        "patchSetId": 2
      },
      "lineNbr": 268,
      "author": {
        "id": 13252
      },
      "writtenOn": "2024-04-09T15:07:22Z",
      "side": 1,
      "message": "I\u0027m not confident that making this dependent on a regex is a good idea. can we have either an explicit parameter for this choice or (given that likely at some point the new version will replace the old one) have different functions where we can make the old one deprecated?\n\nAlso can\u0027t the part after the \":\" also include \"_\"?",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07ad1e3c_e09fa0c7",
        "filename": "lib/apache",
        "patchSetId": 2
      },
      "lineNbr": 268,
      "author": {
        "id": 15334
      },
      "writtenOn": "2024-04-17T10:18:51Z",
      "side": 1,
      "message": "We already have two \"configure uWSGI conf\" functions here - this one and `write_local_uwsgi_http_config` - and I really wanted to avoid adding a third that would need to be kept in-sync, particularly when the current one is liable to fall out of fashion so quickly as we move into a world without `distutils` (and therefore a world without support for pbr\u0027s `wsgi_scripts`).\n\nI\u0027m thinking the presence of a colon in the string is sufficient to indicate that we are talking about module (I mean, they\u0027re valid on Linux but not recommended and I\u0027ve never seen them). Perhaps I could simplify this to a simple \"contains a colon\" check?\n\n```\nif [[ $wsgi \u003d\u003d *\":\"* ]]; then\n```",
      "parentUuid": "ef863c04_e6bf2cf4",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a289348c_17f4e52d",
        "filename": "lib/apache",
        "patchSetId": 2
      },
      "lineNbr": 268,
      "author": {
        "id": 13252
      },
      "writtenOn": "2024-04-17T10:32:59Z",
      "side": 1,
      "message": "How about reversing the check then and requiring file references to have an absolute path?\n\n`if [[ $wsgi \u003d /* ]]; then` iniset wsgi-file ...\n\nNote that `[[ ]]` doesn\u0027t require quotes and `\u003d` is the same as `\u003d\u003d` afaict.",
      "parentUuid": "07ad1e3c_e09fa0c7",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1ee4a48_134b5794",
        "filename": "lib/apache",
        "patchSetId": 2
      },
      "lineNbr": 268,
      "author": {
        "id": 11604
      },
      "writtenOn": "2024-04-17T11:17:22Z",
      "side": 1,
      "message": "`\u003d` is less clear as it not clear that its a comparison so if `\u003d` and `\u003d\u003d` are equivlent we should prefer the latter.",
      "parentUuid": "a289348c_17f4e52d",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa7a26cf_956ecd30",
        "filename": "lib/apache",
        "patchSetId": 2
      },
      "lineNbr": 268,
      "author": {
        "id": 15334
      },
      "writtenOn": "2024-04-19T10:03:34Z",
      "side": 1,
      "message": "\u003e How about reversing the check then and requiring file references to have an absolute path?\n\nThat seems more fragile. Is it not possible for us to (mistakenly) pass a relative path? We can guarantee that a module path contains a colon. Can we guarantee a file path starts with a leading slash?",
      "parentUuid": "c1ee4a48_134b5794",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dccf6dd8_1e8f1f8c",
        "filename": "lib/apache",
        "patchSetId": 2
      },
      "lineNbr": 268,
      "author": {
        "id": 13252
      },
      "writtenOn": "2024-04-19T11:08:19Z",
      "side": 1,
      "message": "Ok, so let\u0027s just stick with this",
      "parentUuid": "fa7a26cf_956ecd30",
      "revId": "a2b8f8835550083ae28ce72eb8c7823a70f5097a",
      "serverId": "4a232e18-c5a9-48ee-94c0-e04e7cca6543"
    }
  ]
}