# lib/ironic
# Functions to control the configuration and operation of the **Ironic** service

# Dependencies:
#
# - ``functions`` file
# - ``DEST``, ``DATA_DIR``, ``STACK_USER`` must be defined
# - ``SERVICE_{TENANT_NAME|PASSWORD}`` must be defined
# - ``SERVICE_HOST``
# - ``KEYSTONE_TOKEN_FORMAT`` must be defined

# ``stack.sh`` calls the entry points in this order:
#
# - install_ironic
# - install_ironicclient
# - init_ironic
# - start_ironic
# - stop_ironic
# - cleanup_ironic

# Save trace setting
XTRACE=$(set +o | grep xtrace)
set +o xtrace


# Defaults
# --------

# Set up default directories
IRONIC_DIR=$DEST/ironic
IRONICCLIENT_DIR=$DEST/python-ironicclient
IRONIC_AUTH_CACHE_DIR=${IRONIC_AUTH_CACHE_DIR:-/var/cache/ironic}
IRONIC_CONF_DIR=${IRONIC_CONF_DIR:-/etc/ironic}
IRONIC_CONF_FILE=$IRONIC_CONF_DIR/ironic.conf
IRONIC_ROOTWRAP_CONF=$IRONIC_CONF_DIR/rootwrap.conf
IRONIC_POLICY_JSON=$IRONIC_CONF_DIR/policy.json

# Set up defaults for functional / integration testing
IRONIC_BAREMETAL_BASIC_OPS=$(trueorfalse False $IRONIC_BAREMETAL_BASIC_OPS)
IRONIC_SSH_USERNAME=${IRONIC_SSH_USERNAME:-`whoami`}
IRONIC_SSH_KEY_DIR=${IRONIC_SSH_KEY_DIR:-$DEST/ssh_keys}
IRONIC_SSH_KEY_FILENAME=${IRONIC_SSH_KEY_FILENAME:-ironic_key}
IRONIC_VM_SSH_PORT=${IRONIC_VM_SSH_PORT:-2222}
IRONIC_VM_SSH_ADDRESS=${IRONIC_VM_SSH_ADDRESS:-127.0.0.1}
IRONIC_VM_COUNT=${IRONIC_VM_COUNT:-1}
IRONIC_VM_SPECS_CPU=${IRONIC_VM_SPECS_CPU:-1}
IRONIC_VM_SPECS_RAM=${IRONIC_VM_SPECS_RAM:-256}
IRONIC_VM_SPECS_DISK=${IRONIC_VM_SPECS_DISK:-1}
IRONIC_VM_NETWORK_BRIDGE=${IRONIC_VM_NETWORK_BRIDGE:-ironic_br}
IRONIC_VM_NETWORK_BRIDGE_ADDRESS=${IRONIC_VM_NETWORK_BRIDGE_ADDRESS:-192.0.2.33/24}
IRONIC_VM_NETWORK_DHCP_RANGE=${IRONIC_VM_NETWORK_DHCP_RANGE:-192.0.2.32,192.0.2.48}
IRONIC_VM_MACS_CSV_FILE=${IRONIC_VM_MACS_CSV_FILE:-$DEST/ironic_macs.csv}
# use default kvm/qemu prefix
IRONIC_VM_MAC_PREFIX=${IRONIC_VM_MAC_PREFIX:-52:54:00}

# Support entry points installation of console scripts
IRONIC_BIN_DIR=$(get_python_exec_prefix)

# Ironic connection info.  Note the port must be specified.
IRONIC_SERVICE_PROTOCOL=http
IRONIC_HOSTPORT=${IRONIC_HOSTPORT:-$SERVICE_HOST:6385}

# Tell Tempest this project is present
TEMPEST_SERVICES+=,ironic


# Functions
# ---------

# Test if any Ironic services are enabled
# is_ironic_enabled
function is_ironic_enabled {
    [[ ,${ENABLED_SERVICES} =~ ,"ir-" ]] && return 0
    return 1
}

# install_ironic() - Collect source and prepare
function install_ironic() {
    git_clone $IRONIC_REPO $IRONIC_DIR $IRONIC_BRANCH
    setup_develop $IRONIC_DIR
}

# install_ironicclient() - Collect sources and prepare
function install_ironicclient() {
    git_clone $IRONICCLIENT_REPO $IRONICCLIENT_DIR $IRONICCLIENT_BRANCH
    setup_develop $IRONICCLIENT_DIR
}

# cleanup_ironic() - Remove residual data files, anything left over from previous
# runs that would need to clean up.
function cleanup_ironic() {
    sudo rm -rf $IRONIC_AUTH_CACHE_DIR
}

# configure_ironic() - Set config files, create data dirs, etc
function configure_ironic() {
    if [[ ! -d $IRONIC_CONF_DIR ]]; then
        sudo mkdir -p $IRONIC_CONF_DIR
    fi
    sudo chown $STACK_USER $IRONIC_CONF_DIR

    # Copy over ironic configuration file and configure common parameters.
    cp $IRONIC_DIR/etc/ironic/ironic.conf.sample $IRONIC_CONF_FILE
    iniset $IRONIC_CONF_FILE DEFAULT debug True
    inicomment $IRONIC_CONF_FILE DEFAULT log_file
    iniset $IRONIC_CONF_FILE DEFAULT sql_connection `database_connection_url ironic`
    iniset $IRONIC_CONF_FILE DEFAULT use_syslog $SYSLOG

    # Configure Ironic conductor, if it was enabled.
    if is_service_enabled ir-cond; then
        configure_ironic_conductor
    fi

    # Configure Ironic API, if it was enabled.
    if is_service_enabled ir-api; then
        configure_ironic_api
    fi

    if [[ "$IRONIC_BAREMETAL_BASIC_OPS" == "True" ]]; then
        configure_ironic_auxiliary
    fi
}

# configure_ironic_api() - Is used by configure_ironic(). Performs
# API specific configuration.
function configure_ironic_api() {
    iniset $IRONIC_CONF_FILE DEFAULT auth_strategy keystone
    iniset $IRONIC_CONF_FILE DEFAULT policy_file $IRONIC_POLICY_JSON
    iniset $IRONIC_CONF_FILE keystone_authtoken auth_host $KEYSTONE_AUTH_HOST
    iniset $IRONIC_CONF_FILE keystone_authtoken auth_port $KEYSTONE_AUTH_PORT
    iniset $IRONIC_CONF_FILE keystone_authtoken auth_protocol $KEYSTONE_AUTH_PROTOCOL
    iniset $IRONIC_CONF_FILE keystone_authtoken cafile $KEYSTONE_SSL_CA
    iniset $IRONIC_CONF_FILE keystone_authtoken auth_uri $KEYSTONE_SERVICE_PROTOCOL://$KEYSTONE_SERVICE_HOST:$KEYSTONE_SERVICE_PORT/
    iniset $IRONIC_CONF_FILE keystone_authtoken admin_tenant_name $SERVICE_TENANT_NAME
    iniset $IRONIC_CONF_FILE keystone_authtoken admin_user ironic
    iniset $IRONIC_CONF_FILE keystone_authtoken admin_password $SERVICE_PASSWORD
    if is_service_enabled qpid; then
        iniset $IRONIC_CONF_FILE DEFAULT notifier_strategy qpid
    elif [ -n "$RABBIT_HOST" ] &&  [ -n "$RABBIT_PASSWORD" ]; then
        iniset $IRONIC_CONF_FILE DEFAULT notifier_strategy rabbit
    fi
    iniset_rpc_backend ironic $IRONIC_CONF_FILE DEFAULT
    iniset $IRONIC_CONF_FILE keystone_authtoken signing_dir $IRONIC_AUTH_CACHE_DIR/api

    cp -p $IRONIC_DIR/etc/ironic/policy.json $IRONIC_POLICY_JSON
}

# configure_ironic_conductor() - Is used by configure_ironic().
# Sets conductor specific settings.
function configure_ironic_conductor() {
    cp $IRONIC_DIR/etc/ironic/rootwrap.conf $IRONIC_ROOTWRAP_CONF
    cp -r $IRONIC_DIR/etc/ironic/rootwrap.d $IRONIC_CONF_DIR

    iniset $IRONIC_CONF DEFAULT rootwrap_config $IRONIC_ROOTWRAP_CONF
}

# create_ironic_cache_dir() - Part of the init_ironic() process
function create_ironic_cache_dir() {
    # Create cache dir
    sudo mkdir -p $IRONIC_AUTH_CACHE_DIR/api
    sudo chown $STACK_USER $IRONIC_AUTH_CACHE_DIR/api
    rm -f $IRONIC_AUTH_CACHE_DIR/api/*
    sudo mkdir -p $IRONIC_AUTH_CACHE_DIR/registry
    sudo chown $STACK_USER $IRONIC_AUTH_CACHE_DIR/registry
    rm -f $IRONIC_AUTH_CACHE_DIR/registry/*
}

# create_ironic_accounts() - Set up common required ironic accounts

# Tenant               User       Roles
# ------------------------------------------------------------------
# service              ironic     admin        # if enabled
create_ironic_accounts() {

    SERVICE_TENANT=$(keystone tenant-list | awk "/ $SERVICE_TENANT_NAME / { print \$2 }")
    ADMIN_ROLE=$(keystone role-list | awk "/ admin / { print \$2 }")

    # Ironic
    if [[ "$ENABLED_SERVICES" =~ "ir-api" ]]; then
        IRONIC_USER=$(keystone user-create \
            --name=ironic \
            --pass="$SERVICE_PASSWORD" \
            --tenant-id $SERVICE_TENANT \
            --email=ironic@example.com \
            | grep " id " | get_field 2)
        keystone user-role-add \
            --tenant-id $SERVICE_TENANT \
            --user_id $IRONIC_USER \
            --role_id $ADMIN_ROLE
        if [[ "$KEYSTONE_CATALOG_BACKEND" = 'sql' ]]; then
            IRONIC_SERVICE=$(keystone service-create \
                --name=ironic \
                --type=baremetal \
                --description="Ironic baremetal provisioning service" \
                | grep " id " | get_field 2)
            keystone endpoint-create \
                --region RegionOne \
                --service_id $IRONIC_SERVICE \
                --publicurl "$IRONIC_SERVICE_PROTOCOL://$IRONIC_HOSTPORT" \
                --adminurl "$IRONIC_SERVICE_PROTOCOL://$IRONIC_HOSTPORT" \
                --internalurl "$IRONIC_SERVICE_PROTOCOL://$IRONIC_HOSTPORT"
        fi
    fi
}


# init_ironic() - Initialize databases, etc.
function init_ironic() {
    # (Re)create  ironic database
    recreate_database ironic utf8

    # Migrate ironic database
    $IRONIC_BIN_DIR/ironic-dbsync

    create_ironic_cache_dir

    # Create keystone artifacts for Ironic.
    create_ironic_accounts
}

# start_ironic() - Start running processes, including screen
function start_ironic() {
    # Start Ironic API server, if enabled.
    if is_service_enabled ir-api; then
        start_ironic_api
    fi

    # Start Ironic conductor, if enabled.
    if is_service_enabled ir-cond; then
        start_ironic_conductor
    fi
}

# start_ironic_api() - Used by start_ironic().
# Starts Ironic API server.
function start_ironic_api() {
    screen_it ir-api "cd $IRONIC_DIR; $IRONIC_BIN_DIR/ironic-api --config-file=$IRONIC_CONF_FILE"
    echo "Waiting for ir-api ($IRONIC_HOSTPORT) to start..."
    if ! timeout $SERVICE_TIMEOUT sh -c "while ! wget --no-proxy -q -O- http://$IRONIC_HOSTPORT; do sleep 1; done"; then
        die $LINENO "ir-api did not start"
    fi
}

# start_ironic_conductor() - Used by start_ironic().
# Starts Ironic conductor.
function start_ironic_conductor() {
    screen_it ir-cond "cd $IRONIC_DIR; $IRONIC_BIN_DIR/ironic-conductor --config-file=$IRONIC_CONF_FILE"
    # TODO(romcheg): Find a way to check whether the conductor has started.
}

# stop_ironic() - Stop running processes
function stop_ironic() {
    # Kill the Ironic screen windows
    screen -S $SCREEN_NAME -p ir-api -X kill
    screen -S $SCREEN_NAME -p ir-cond -X kill
}

function is_ironic() {
    if ( is_service_enabled ir-cond && is_service_enabled ir-api ); then
        return 0
    fi
    return 1
}

function configure_ironic_dirs() {
    # ensure /tftpboot is prepared

    #TODO(agordeev): chown to ironic's user
    sudo mkdir -p /var/lib/ironic
    sudo mkdir -p /tftpboot
    sudo chmod 777 /var/lib/ironic
    sudo chmod 777 /tftpboot
    sudo mkdir -p /tftpboot/pxelinux.cfg

    if is_ubuntu; then
        PXEBIN=/usr/lib/syslinux/pxelinux.0
    elif is_fedora; then
        PXEBIN=/usr/share/syslinux/pxelinux.0
    fi
    if [ ! -f $PXEBIN ]; then
        die $LINENO "pxelinux.0 (from SYSLINUX) not found."
    fi

    sudo cp_it $PXEBIN /tftpboot/
    sudo chown -R $STACK_USER:$LIBVIRT_GROUP /tftpboot
}

function start_dnsmasq_for_vms() {
    #TODO(agordeev): remove this once neutron integration becomes ready

    if ! ps -e | grep dnsmasq | grep /tftpboot; then
        sudo dnsmasq --conf-file= --port=69 --enable-tftp --tftp-root=/tftpboot --dhcp-boot=pxelinux.0 --pid-file=/var/run/dnsmasq.pid --interface=$IRONIC_VM_NETWORK_BRIDGE --dhcp-range=$IRONIC_VM_NETWORK_DHCP_RANGE
    fi

}

function _get_mac() {
        echo $IRONIC_VM_MAC_PREFIX:$(printf '%02X:%02X:%02X' $[RANDOM%256] $[RANDOM%256] $[RANDOM%256])
}

function create_brigde_and_vms() {

    #TODO(agordeev): remove this once neutron integration becomes ready
    sudo brctl addbr $IRONIC_VM_NETWORK_BRIDGE
    sudo ip addr add $IRONIC_VM_NETWORK_BRIDGE_ADDRESS dev $IRONIC_VM_NETWORK_BRIDGE

    touch $IRONIC_VM_MACS_CSV_FILE

    for i in `seq $IRONIC_VM_COUNT`; do
        MAC=_get_mac
        NODE=node-$i
        echo $NODE,$MAC >> $IRONIC_VM_MACS_CSV_FILE

        virt-install \
            --connect qemu:///system \
            --virt-type qemu \
            --name $NODE \
            --vcpus $IRONIC_VM_SPECS_CPU \
            --ram $IRONIC_VM_SPECS_RAM \
            --disk path=/var/lib/libvirt/images/$NODE.img,size=$IRONIC_VM_SPECS_DISK \
            --vnc \
            --network bridge=$IRONIC_VM_NETWORK_BRIDGE,mac=$MAC \
            --pxe \
            --boot network,hd \
            --noreboot \
            --noautoconsole

        #FIXME(agordeev): adding this to prevent domain starting after virt-install installation
        virsh destroy $NODE

    done

}

function enroll_vms() {

    SOURCE_IMAGE_ID=$(glance image-list | grep $DEFAULT_IMAGE_NAME -m1 | get_field 1)

    CHASSIS_ID=$(ironic chassis-create -d "ironic test chassis" | grep " uuid " | get_field 2)

    while IFS="," read NODE MAC; do
        NODE_ID=$(ironic node-create --chassis_uuid $CHASSIS_ID --driver pxe_ssh \
            -i ssh_virt_type=virsh \
            -i ssh_address=$IRONIC_VM_SSH_ADDRESS \
            -i ssh_port=$IRONIC_VM_SSH_PORT \
            -i ssh_username=$IRONIC_SSH_USERNAME \
            -i ssh_key_filename=$IRONIC_SSH_KEY_DIR/$IRONIC_SSH_KEY_FILENAME \
            -i pxe_deploy_ramdisk=$BM_DEPLOY_RAMDISK_ID \
            -i pxe_deploy_kernel=$BM_DEPLOY_KERNEL_ID \
            -i pxe_instance_name="test-$NODE" \
            -i pxe_image_source=$SOURCE_IMAGE_ID \
            -i pxe_root_gb=$IRONIC_VM_SPECS_DISK \
            | grep " uuid " | get_field 2)

        ironic port-create --address $MAC --node_uuid $NODE_ID

        ironic node-validate $NODE_ID | grep " power " | get_field 2 | grep result | grep True || die $LINENO "Wrong driver power result"
        ironic node-validate $NODE_ID | grep " deploy " | get_field 2 | grep result | grep True || die $LINENO "Wrong driver deploy result"

        ironic node-update $NODE_ID replace instance_uuid=`uuidgen`

    done < $IRONIC_VM_MACS_CSV_FILE
}


function configure_ironic_ssh_keypair() {
    # Generating ssh key pair for stack user
    if [[ ! -d $IRONIC_SSH_KEY_DIR ]]; then
        mkdir -p $IRONIC_SSH_KEY_DIR
    fi
    # avoid overwriting already existent keypair
    echo -e 'n\n' | ssh-keygen -q -t rsa -P '' -f $IRONIC_SSH_KEY_DIR/$IRONIC_SSH_KEY_FILENAME
    if [[ ! -d $HOME/.ssh ]]; then
        mkdir -p $HOME/.ssh
        chmod 700 $HOME/.ssh
    fi

    KEY=`cat $IRONIC_SSH_KEY_DIR/$IRONIC_SSH_KEY_FILENAME.pub`
    if ! grep "$KEY" $HOME/.ssh/authorized_keys; then
        echo $KEY | tee -a $HOME/.ssh/authorized_keys
    fi

}

function _ssh_check() {
    local KEY_FILE=$1
    local FLOATING_IP=$2
    local PORT=$3
    local DEFAULT_INSTANCE_USER=$4
    local ACTIVE_TIMEOUT=$5
    if ! timeout $ACTIVE_TIMEOUT sh -c "while ! ssh -p $PORT -o StrictHostKeyChecking=no -i $KEY_FILE ${DEFAULT_INSTANCE_USER}@$FLOATING_IP echo success; do sleep 1; done"; then
        die $LINENO "server didn't become ssh-able!"
    fi
}

function configure_ironic_sshd() {
    # Ensure sshd server accepts connections from localhost only

    SSH_CONFIG=/etc/ssh/sshd_config
    HOST_PORT=$IRONIC_VM_SSH_ADDRESS:$IRONIC_VM_SSH_PORT
    if ! sudo grep ListenAddress $SSH_CONFIG | grep $HOST_PORT; then
        echo "ListenAddress $HOST_PORT" | sudo tee -a $SSH_CONFIG
    fi

    restart_service ssh

    _ssh_check $IRONIC_SSH_KEY_DIR/$IRONIC_SSH_KEY_FILENAME $IRONIC_VM_SSH_ADDRESS $IRONIC_VM_SSH_PORT $IRONIC_SSH_USERNAME 10

}

function configure_ironic_auxiliary() {
    configure_ironic_dirs
    configure_ironic_ssh_keypair
    configure_ironic_sshd
}

# Restore xtrace
$XTRACE

# Tell emacs to use shell-script-mode
## Local variables:
## mode: shell-script
## End:
