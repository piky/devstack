# Quantum Cisco plugin
# ---------------------------

# Save trace setting
MY_XTRACE=$(set +o | grep xtrace)
set +o xtrace

# Indicate if a VSM instance should be created
Q_CISCO_PLUGIN_DEVSTACK_VSM=${Q_CISCO_PLUGIN_DEVSTACK_VSM:-True}
# Set the interface ip that is used to tap into the VSM
Q_CISCO_PLUGIN_TAP_VSM_IP=${Q_CISCO_PLUGIN_TAP_VSM_IP:-172.16.1.225/28}
# Specify the VSM image file
Q_CISCO_PLUGIN_VSM_ISO_IMAGE=${Q_CISCO_PLUGIN_VSM_ISO_IMAGE:-}

NCCLIENT_DIR=$DEST/ncclient
NCCLIENT_VERSION=${NCCLIENT_VERSION:-0.3.1}
NCCLIENT_REPO=${NCCLIENT_REPO:-${GIT_BASE}/CiscoSystems/ncclient.git}
NCCLIENT_BRANCH=${NCCLIENT_BRANCH:-master}

function _prefix_function() {
    declare -F $1 > /dev/null || die "$1 doesn't exist"
    eval "$(echo "${2}_${1}()"; declare -f ${1} | tail -n +2)"
}

function _has_ovs_subplugin() {
    local subplugin
    for subplugin in ${Q_CISCO_PLUGIN_SUBPLUGINS[@]}; do
        if [[ "$subplugin" == "openvswitch" ]]; then
            return 0
        fi
    done
    return 1
}

function _has_nexus_subplugin() {
    local subplugin
    for subplugin in ${Q_CISCO_PLUGIN_SUBPLUGINS[@]}; do
        if [[ "$subplugin" == "nexus" ]]; then
            return 0
        fi
    done
    return 1
}

function _has_n1kv_subplugin() {
    local subplugin
    for subplugin in ${Q_CISCO_PLUGIN_SUBPLUGINS[@]}; do
        if [[ "$subplugin" == "n1kv" ]]; then
            return 0
        fi
    done
    return 1
}

function _config_switch() {
    local cisco_cfg_file=$1
    local switch_ip=$2
    local username=$3
    local password=$4
    local ssh_port=$5
    shift 5

    local section="NEXUS_SWITCH:$switch_ip"
    iniset $cisco_cfg_file $section username $username
    iniset $cisco_cfg_file $section password $password
    iniset $cisco_cfg_file $section ssh_port $ssh_port

    while [[ ${#@} != 0 ]]; do
        iniset  $cisco_cfg_file $section $1 $2
        shift 2
    done
}

source $TOP_DIR/lib/quantum_plugins/openvswitch
_prefix_function quantum_plugin_create_nova_conf ovs
_prefix_function quantum_plugin_install_agent_packages ovs
_prefix_function quantum_plugin_configure_common ovs
_prefix_function quantum_plugin_configure_debug_command ovs
_prefix_function quantum_plugin_configure_dhcp_agent ovs
_prefix_function quantum_plugin_configure_l3_agent ovs
_prefix_function quantum_plugin_configure_plugin_agent ovs
_prefix_function quantum_plugin_configure_service ovs
_prefix_function quantum_plugin_setup_interface_driver ovs

function check_ncclient_version() {
python << EOF
version = '$NCCLIENT_VERSION'
import sys
try:
    import pkg_resources
    import ncclient
    module_version = pkg_resources.get_distribution('ncclient').version
    if version != module_version:
        sys.exit(1)
except:
    sys.exit(1)
EOF
}

function install_ncclient() {
    git_clone $NCCLIENT_REPO $NCCLIENT_DIR $NCCLIENT_BRANCH
    (cd $NCCLIENT_DIR; sudo python setup.py install)
}

function is_ncclient_installed() {
    # Check if the Cisco ncclient repository exists
    if [[ -d $NCCLIENT_DIR ]]; then
        remotes=$(cd $NCCLIENT_DIR; git remote -v | grep fetch | awk '{ print $2}')
        for remote in $remotes; do
            if [[ $remote == $NCCLIENT_REPO ]]; then
                break;
            fi
        done
        if [[ $remote != $NCCLIENT_REPO ]]; then
            return 1
        fi
    else
        return 1
    fi

    # Check if the ncclient is installed with the right version
    if ! check_ncclient_version; then
        return 1
    fi
    return 0
}

function reset_nexus_switch() {
    python <<-EOF
	nexus_host = '$1'
	nexus_info = '$2'
	vlan_ranges = '$3'

	EXEC_CONF_SNIPPET = """
	      <config xmlns:xc="urn:ietf:params:xml:ns:netconf:base:1.0">
		<configure>
		  <__XML__MODE__exec_configure>%s
		  </__XML__MODE__exec_configure>
		</configure>
	      </config>
	"""

	CMD_NO_SWITCHPORT = EXEC_CONF_SNIPPET % """
		  <interface>
		    <ethernet>
		      <interface>%s</interface>
		      <__XML__MODE_if-ethernet-switch>
			<no>
			  <switchport>
			  </switchport>
			</no>
		      </__XML__MODE_if-ethernet-switch>
		    </ethernet>
		  </interface>
	"""

	CMD_SWITCHPORT = EXEC_CONF_SNIPPET % """
		  <interface>
		    <ethernet>
		      <interface>%s</interface>
		      <__XML__MODE_if-ethernet-switch>
			  <switchport>
			  </switchport>
			  <switchport>
			      <mode>
				  <trunk>
				  </trunk>
			      </mode>
			  </switchport>
			  <switchport>
			      <trunk>
				  <allowed>
				      <vlan>
					  <none>
					  </none>
				      </vlan>
				  </allowed>
			      </trunk>
			  </switchport>
		      </__XML__MODE_if-ethernet-switch>
		    </ethernet>
		  </interface>
	"""

	CMD_NO_VLAN_RANGE = EXEC_CONF_SNIPPET % """
		  <no>
		  <vlan>
		    <vlan-id-create-delete>
		      <__XML__PARAM_value>%s-%s</__XML__PARAM_value>
		    </vlan-id-create-delete>
		  </vlan>
		  </no>
	"""

	from ncclient import manager as ncm
	from ncclient import NCClientError
	import sys

	nexus_info = nexus_info.split(':')
	nexus_username = nexus_info[0].strip()
	nexus_passwd = nexus_info[1].strip()
	nexus_ssh_port = nexus_info[2].strip()
	nexus_ports = nexus_info[3:]
	vlan_ranges = vlan_ranges.split(',')

	print nexus_username, nexus_passwd, nexus_ssh_port, nexus_ports


	if len(nexus_ports) == 0 or len(nexus_ports) % 2 != 0:
	    print "Incorrect ports info: %s" % nexus_ports
	    sys.exit(1)

	port_count = len(nexus_ports) / 2

	# Connect to the Nexus switch
	try:
	    nexus_manager = ncm.connect(host=nexus_host, port=nexus_ssh_port,
					username=nexus_username,
					password=nexus_passwd,
					timeout=10)
	except NCClientError as e:
	    print "Failed to connect: %s" % e
	    sys.exit(1)

	for port_no in xrange(port_count):
	    port_id = nexus_ports[port_no * 2 + 1].strip()
	    try:
		nexus_manager.edit_config(target="running",
					  config=CMD_NO_SWITCHPORT % port_id)
		nexus_manager.edit_config(target="running",
					  config=CMD_SWITCHPORT % port_id)
	    except NCClientError as e:
		print "Failed to configure switchport %s: %s" % (port_id, e)
		sys.exit(1)

	for vlan_range in vlan_ranges:
	    vlan_range = vlan_range.strip()
	    if ':' in vlan_range:
		try:
		    physical_network, vlan_min, vlan_max = vlan_range.split(':')
		except ValueError as e:
		    print "Invalid network VLAN range: %s" % vlan_range
		    sys.exit(1)

		try:
		    nexus_manager.edit_config(target="running",
				     config=CMD_NO_VLAN_RANGE % (vlan_min, vlan_max))
		except NCClientError as e:
		    if str(e).find("ERROR: Delete failed, VLAN does not exist") == -1:
			print "Failed to reset vlan range "\
			      "%s-%s: %s" % (vlan_min, vlan_max, e)
			sys.exit(1)
	EOF
}

function has_quantum_plugin_security_group() {
    return 1
}

function is_quantum_ovs_base_plugin() {
    # Cisco uses OVS
    _has_ovs_subplugin
    return
}

function quantum_plugin_create_nova_conf() {
    if _has_ovs_subplugin; then
        ovs_quantum_plugin_create_nova_conf
    else
        NOVA_VIF_DRIVER=${NOVA_VIF_DRIVER:-"nova.virt.libvirt.vif.LibvirtHybridOVSBridgeDriver"}
    fi
}

function quantum_plugin_install_agent_packages() {
    # Cisco plugin uses openvswitch to operate
    ovs_quantum_plugin_install_agent_packages
}

function quantum_plugin_configure_common() {
    # setup default subplugins
    if [ ! -v Q_CISCO_PLUGIN_SUBPLUGINS ]; then
        declare -ga Q_CISCO_PLUGIN_SUBPLUGINS
        Q_CISCO_PLUGIN_SUBPLUGINS=(openvswitch nexus)
    fi
    if _has_ovs_subplugin; then
        ovs_quantum_plugin_configure_common
        Q_PLUGIN_EXTRA_CONF_PATH=etc/quantum/plugins/cisco
        Q_PLUGIN_EXTRA_CONF_FILES=(cisco_plugins.ini)
    else
        Q_PLUGIN_CONF_PATH=etc/quantum/plugins/cisco
        Q_PLUGIN_CONF_FILENAME=cisco_plugins.ini
    fi
    Q_PLUGIN_CLASS="quantum.plugins.cisco.network_plugin.PluginV2"
    Q_DB_NAME=cisco_quantum
}

function quantum_plugin_configure_debug_command() {
    if _has_ovs_subplugin; then
        ovs_quantum_plugin_configure_debug_command
    fi
}

function quantum_plugin_configure_dhcp_agent() {
    iniset $Q_DHCP_CONF_FILE DEFAULT dhcp_agent_manager quantum.agent.dhcp_agent.DhcpAgentWithStateReport
}

function quantum_plugin_configure_l3_agent() {
    if _has_ovs_subplugin; then
        ovs_quantum_plugin_configure_l3_agent
    fi
}

function quantum_plugin_configure_plugin_agent() {
    if _has_ovs_subplugin; then
        ovs_quantum_plugin_configure_plugin_agent
    else
        OVS_BRIDGE=${OVS_BRIDGE:-br-int}
        _quantum_ovs_base_setup_bridge $OVS_BRIDGE
    fi
}

function _config_nexus_subplugin() {
    local cisco_cfg_file=$1

    # Install Cisco ncclient if necessary
    if ! is_ncclient_installed; then
	# Preserve the two global variables
	local offline=$OFFLINE
	local reclone=$RECLONE
	# Change their values to allow installation
	OFFLINE=False
	RECLONE=yes
	install_ncclient
	# Restore their values
	OFFLINE=$offline
	RECLONE=$reclone
    fi

    inicomment $cisco_cfg_file CISCO_TEST host
    # Setup default nexus switch information
    if [ ! -v Q_CISCO_PLUGIN_SWITCH_INFO ]; then
	declare -A Q_CISCO_PLUGIN_SWITCH_INFO
	HOST_NAME=$(hostname)
	Q_CISCO_PLUGIN_SWITCH_INFO=([1.1.1.1]=stack:stack:22:${HOST_NAME}:1/10)
    else
	iniset $cisco_cfg_file CISCO nexus_driver quantum.plugins.cisco.nexus.cisco_nexus_network_driver_v2.CiscoNEXUSDriver
    fi

    # Setup the switch configurations
    local nswitch
    local sw_info
    local segment
    local sw_info_array
    declare -i count=0
    for nswitch in ${!Q_CISCO_PLUGIN_SWITCH_INFO[@]}; do
	sw_info=${Q_CISCO_PLUGIN_SWITCH_INFO[$nswitch]}
	sw_info_array=${sw_info//:/ }
	sw_info_array=( $sw_info_array )
	count=${#sw_info_array[@]}
	if [[ $count < 5 || $(( ($count-3) % 2 )) != 0 ]]; then
	    die $LINENO "Incorrect switch configuration: ${Q_CISCO_PLUGIN_SWITCH_INFO[$nswitch]}"
	fi
	_config_switch $cisco_cfg_file $nswitch ${sw_info_array[@]}
	# Assuming OVS is one of the subplugins for now
	vlan_ranges=${OVS_VLAN_RANGES:-none}
	reset_nexus_switch $nswitch $sw_info $vlan_ranges
    done
}

function _get_vsm_state() {
    vsm_state=$(sudo virsh list --all | awk '(NR > 2) {if (($2 == "DEVSTACK_VSM")) {$1="";$2="";print;}}')
}

function _create_devstack_vsm() {
    # Intall krdc package
    install_package krdc

    if [[ -z "$Q_CISCO_PLUGIN_VSM_ISO_IMAGE" ]]; then
        die $LINENO "Please specify your VSM iso image in the localrc file!"
    fi
    if [[ ! -f "$Q_CISCO_PLUGIN_VSM_ISO_IMAGE" ]]; then
        die $LINENO "Can't find the VSM iso image file $Q_CISCO_PLUGIN_VSM_ISO_IMAGE!"
    fi

    local vsm_image_file=$DATA_DIR/quantum/cisco/DEVSTACK_VSM.img

    vsm_uuid=$(uuidgen -t)

    _get_vsm_state

    # VSM doesn't exist; create one
    if [[ $vsm_state == '' ]]; then 
	mkdir -p $DATA_DIR/quantum/cisco

	cat > $DATA_DIR/quantum/cisco/DEVSTACK_VSM.xml <<-EOF
	    <domain type='qemu'>
	        <name>DEVSTACK_VSM</name>
	        <uuid>$vsm_uuid</uuid> 
	        <memory unit='KiB'>2048000</memory> 
	        <currentMemory unit='KiB'>1024000</currentMemory> 
	        <vcpu placement='static'>1</vcpu>
	        <os>
	            <type arch='x86_64' machine='pc-1.0'>hvm</type> 
	            <boot dev='cdrom'/>
	            <boot dev='hd'/>
	        </os>

	        <features> <acpi/> <apic/> <pae/> </features>

	        <clock offset='localtime'/> 
	        <on_poweroff>destroy</on_poweroff>
	        <on_reboot>destroy</on_reboot> 
	        <on_crash>destroy</on_crash> 

	        <devices>
	            <emulator>/usr/bin/qemu-system-x86_64</emulator> 
	            <disk type='file' device='disk'>
	                <driver name='qemu' type='raw'/>
	                <source file='$vsm_image_file'/> 
	                <target dev='hda' bus='ide'/>
	                <alias name='ide0-0-0'/>
	                <address type='drive' controller='0' bus='0' target='0' unit='0'/>
	            </disk>
	            <disk type='file' device='cdrom'>
	                <driver name='qemu' type='raw'/>
	                <source file='$Q_CISCO_PLUGIN_VSM_ISO_IMAGE'/>
	                <target dev='hdb' bus='ide'/>
	                <readonly/>
	                <alias name='ide0-0-1'/>
	                <address type='drive' controller='0' bus='0' target='0' unit='1'/>
	            </disk>

	            <controller type='usb' index='0'>
	                <alias name='usb0'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x2'/> 
	            </controller>

	            <controller type='ide' index='0'>
	                <alias name='ide0'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x01' function='0x1'/> 
	            </controller>

	            <interface type='bridge'>
	                <mac address='0e:1f:35:ab:45:2e'/> 
	                <source bridge='ds-vsm-bridge'/>
	                <target dev='ds-vsm-vnet0'/>
	                <model type='e1000'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/>
	            </interface>

	            <interface type='bridge'>
	                <mac address='0e:1f:35:ab:45:3e'/>
	                <source bridge='ds-vsm-bridge'/>
	                <target dev='ds-vsm-vnet1'/>
	                <model type='e1000'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x06' function='0x0'/>
	            </interface> 

	            <interface type='bridge'>
	                <mac address='0e:1f:35:ab:45:4e'/>
	                <source bridge='ds-vsm-bridge'/>
	                <target dev='ds-vsm-vnet2'/>
	                <model type='e1000'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
	            </interface> 

	            <serial type='pty'>
	                <target port='0'/>
	            </serial>
	            <console type='pty'>
	                <target type='serial' port='0'/>
	            </console>
	            <input type='mouse' bus='ps2'/>
	            <graphics type='vnc' port='5900' autoport='yes' listen='0.0.0.0' keymap='en-us'>
	                <listen type='address' address='0.0.0.0'/> 
	            </graphics>

	            <video>
	                <model type='cirrus' vram='9216' heads='1'/>
	                <alias name='video0'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
	            </video>

	            <memballoon model='virtio'>
	                <alias name='balloon0'/>
	                <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/> 
	            </memballoon>

	        </devices>
	    </domain>
	EOF
	sudo qemu-img create $DATA_DIR/quantum/cisco/DEVSTACK_VSM.img 8G

	sudo virsh define $DATA_DIR/quantum/cisco/DEVSTACK_VSM.xml
	_get_vsm_state
    fi

    if [[ "$vsm_state" == "  shut off" ]]; then
	sudo brctl addbr ds-vsm-bridge 
	sudo ip link set ds-vsm-bridge up
	sudo ip link add tap-ds-vsm type veth peer name ds-vsm-veth
	sudo ip link set tap-ds-vsm up
	sudo ip link set tap-ds-vsm promisc on
	sudo ip link set ds-vsm-veth up
	sudo ip link set ds-vsm-veth promisc on
	sudo brctl addif ds-vsm-bridge tap-ds-vsm
	sudo ip -4 addr add $Q_CISCO_PLUGIN_TAP_VSM_IP dev ds-vsm-veth
	sudo virsh start DEVSTACK_VSM
	if [[ $? ]]; then 
	    vnc_no=$(sudo virsh vncdisplay DEVSTACK_VSM)
	    krdc localhost$vnc_no&
            disown %%
	fi
    fi
}

function _configure_n1kv_subplugin() {
    local cisco_cfg_file=$1

    if [[ "$Q_CISCO_PLUGIN_DEVSTACK_VSM" == "True" ]]; then
        _create_devstack_vsm
    fi
}

function quantum_plugin_configure_service() {
    local subplugin
    local cisco_cfg_file
    if _has_ovs_subplugin; then
        ovs_quantum_plugin_configure_service
        cisco_cfg_file=/${Q_PLUGIN_EXTRA_CONF_FILES[0]}
    else
        cisco_cfg_file=/$Q_PLUGIN_CONF_FILE
    fi

    # Setup the [CISCO_PLUGINS] section
    if [[ ${#Q_CISCO_PLUGIN_SUBPLUGINS[@]} > 2 ]]; then
        die $LINENO "At most two subplugins are supported."
    fi

    if _has_ovs_subplugin && _has_n1kv_subplugin; then
        die $LINENO "OVS subplugin and n1kv subplugin cannot coexist"
    fi

    # TO BE REMOVED. This is temporarily needed for the old-styled config to
    # work
    iniset $QUANTUM_CONF DEFAULT config_dir /etc/quantum/plugins/cisco

    inicomment $cisco_cfg_file CISCO_PLUGINS nexus_plugin
    inicomment $cisco_cfg_file CISCO_PLUGINS vswitch_plugin
    for subplugin in ${Q_CISCO_PLUGIN_SUBPLUGINS[@]}; do
        case $subplugin in
            nexus) iniset $cisco_cfg_file CISCO_PLUGINS nexus_plugin quantum.plugins.cisco.nexus.cisco_nexus_plugin_v2.NexusPlugin;;
            openvswitch) iniset $cisco_cfg_file CISCO_PLUGINS vswitch_plugin quantum.plugins.openvswitch.ovs_quantum_plugin.OVSQuantumPluginV2;;
            n1kv) iniset $cisco_cfg_file CISCO_PLUGINS vswitch_plugin quantum.plugins.cisco.n1kv.n1kv_quantum_plugin.N1kvQuantumPluginV2;;
            *) die $LINENO "Unsupported cisco subplugin: $subplugin";;
        esac
    done

    if _has_nexus_subplugin; then
        _configure_nexus_subplugin $cisco_cfg_file
    fi

    if _has_n1kv_subplugin; then
        _configure_n1kv_subplugin $cisco_cfg_file
    fi
}

function quantum_plugin_setup_interface_driver() {
    local conf_file=$1
    iniset $conf_file DEFAULT interface_driver quantum.agent.linux.interface.OVSInterfaceDriver
}

# Restore xtrace
$MY_XTRACE
