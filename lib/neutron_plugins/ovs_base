#!/bin/bash
#
# common functions for ovs based plugin
# -------------------------------------

# Save trace setting
OVSB_XTRACE=$(set +o | grep xtrace)
set +o xtrace

OVS_BRIDGE=${OVS_BRIDGE:-br-int}
PUBLIC_BRIDGE=${PUBLIC_BRIDGE:-br-ex}
OVS_DATAPATH_TYPE=${OVS_DATAPATH_TYPE:-""}

function is_neutron_ovs_base_plugin {
    # Yes, we use OVS.
    return 0
}

function _neutron_ovs_base_setup_bridge {
    local bridge=$1
    neutron-ovs-cleanup
    sudo ovs-vsctl --no-wait -- --may-exist add-br $bridge
    if [[ $OVS_DATAPATH_TYPE != "" ]]; then
        sudo ovs-vsctl set Bridge $bridge datapath_type=${OVS_DATAPATH_TYPE}
    fi
    sudo ovs-vsctl --no-wait br-set-external-id $bridge bridge-id $bridge
}

function neutron_ovs_base_cleanup {
    # remove all OVS ports that look like Neutron created ports
    for port in $(sudo ovs-vsctl list port | grep -o -e [a-zA-Z\-]*tap[0-9a-f\-]* -e q[rg]-[0-9a-f\-]*); do
        sudo ovs-vsctl del-port ${port}
    done

    # remove all OVS bridges created by Neutron
    for bridge in $(sudo ovs-vsctl list-br | grep -o -e ${OVS_BRIDGE} -e ${PUBLIC_BRIDGE}); do
        sudo ovs-vsctl del-br ${bridge}
    done
}

function _neutron_ovs_base_install_ubuntu_dkms {
    # install Dynamic Kernel Module Support packages if needed
    local kernel_version=$(uname -r)
    local kernel_major_minor=`echo $kernel_version | cut -d. -f1-2`
    # From kernel 3.13 on, openvswitch-datapath-dkms is not needed
    if [ `vercmp_numbers "$kernel_major_minor" "3.13"` -lt "0" ]; then
        install_package "dkms openvswitch-datapath-dkms linux-headers-$kernel_version"
    fi
}

function _neutron_ovs_base_install_agent_packages {
    # Install deps
    install_package $(get_packages "openvswitch")
    if is_ubuntu; then
        _neutron_ovs_base_install_ubuntu_dkms
        restart_service openvswitch-switch
    elif is_fedora; then
        restart_service openvswitch
    elif is_suse; then
        restart_service openvswitch-switch
    fi
}

function _neutron_ovs_base_configure_debug_command {
    if [ "$Q_USE_PROVIDERNET_FOR_PUBLIC" = "True" ]; then
        iniset $NEUTRON_TEST_CONFIG_FILE DEFAULT external_network_bridge ""
    else
        iniset $NEUTRON_TEST_CONFIG_FILE DEFAULT external_network_bridge $PUBLIC_BRIDGE
    fi
}

function _neutron_ovs_base_configure_firewall_driver {
    if [[ "$Q_USE_SECGROUP" == "True" ]]; then
        iniset /$Q_PLUGIN_CONF_FILE securitygroup firewall_driver neutron.agent.linux.iptables_firewall.OVSHybridIptablesFirewallDriver
    else
        iniset /$Q_PLUGIN_CONF_FILE securitygroup firewall_driver neutron.agent.firewall.NoopFirewallDriver
    fi
}

function _neutron_ovs_base_configure_l3_agent {
    if [ "$Q_USE_PROVIDERNET_FOR_PUBLIC" = "True" ]; then
        iniset $Q_L3_CONF_FILE DEFAULT external_network_bridge ""
    else
        iniset $Q_L3_CONF_FILE DEFAULT external_network_bridge $PUBLIC_BRIDGE
    fi

    neutron-ovs-cleanup
    if [[ "$Q_USE_PUBLIC_VETH" = "True" ]]; then
        ip link show $Q_PUBLIC_VETH_INT > /dev/null 2>&1 ||
        sudo ip link add $Q_PUBLIC_VETH_INT type veth \
            peer name $Q_PUBLIC_VETH_EX
        sudo ip link set $Q_PUBLIC_VETH_INT up
        sudo ip link set $Q_PUBLIC_VETH_EX up
        sudo ip addr flush dev $Q_PUBLIC_VETH_EX
    else
        # --no-wait causes a race condition if $PUBLIC_BRIDGE is not up when ip addr flush is called
        sudo ovs-vsctl -- --may-exist add-br $PUBLIC_BRIDGE
        sudo ovs-vsctl br-set-external-id $PUBLIC_BRIDGE bridge-id $PUBLIC_BRIDGE
        # ensure no IP is configured on the public bridge
        sudo ip addr flush dev $PUBLIC_BRIDGE
    fi
    local mtu=${Q_GUEST_DEVICE_MTU:-$(_neutron_ovs_device_mtu)}
    if [[ $mtu != "nochange" ]]; then
        sudo ip link set mtu $mtu dev $PUBLIC_BRIDGE
    fi
}

# This helper function for setting maximum usable MTU
# Generally good practice to allow the guests to use maximum available MTU size,
# because many of networking operation is done per frame basis.
# If you can send the same amount of data in less frames you need to handle less IRQ,
# process less packet header and you are using less bytes for protocol headers in total.
# This function assumes you already configured your physical interface with the maximum MTU,
# which can be handled by your NIC and physical switches. If you would like to use different MTU
# then the detected one use ``Q_GUEST_DEVICE_MTU`` variable.
# By default the guests assumes 1500 byte MTU, which can be problematic when you are using
# a physical network which cannot send tunneling_overhead + gust_device_mtu size frames.
# In this case you should advertise 1500 - tunneling_overhead MTU size to guests via dhcp.
# Otherwise the packet will be dropped silently by ovs, when the encapsulated size does not fits into
# the physical max MTU size.
# The virtual interfaces created by nova/neutron should have the same max MTU size as the guest vm using.
# When the physical network maximum MTU size is great, for ex.: 9216, the guest only attempts to
# send physical_net_max_mtu - tunneling_overhead, when the guest knows it is doable.
# The bigger max MTU size should be advertised via dhcp.
# If the guest needs to communicate with lower MTU networks, make sure your network
# does not filters ICMP "Can't Fragment" messages, and you router is able to send these messages
# when it's needed.
# See also: http://en.wikipedia.org/wiki/Path_MTU_Discovery
#
# The veth_mtu option is used on the veth pairs between br-int and br-tun with older ovs version,
# it needs to carry an extra 802.1q heade, guest mtu size + 4 byte.

function _neutron_ovs_device_mtu {
    local tunneling=$(trueorfalse True $ENABLE_TENANT_TUNNELS)
    local mtu="nochange"
    if [[ $tunneling == True ]]; then
        mtu=$(get_mtu_for_ip "$TUNNEL_ENDPOINT_IP")
        # No other non ml2 generic network type variable
        # Most ovs consumer driver is ml2 aware now
        case "$Q_ML2_TENANT_NETWORK_TYPE" in
            vxlan)
                (( mtu-= 50 ))
                ;;
            gre64)
                (( mtu-= 32 ))
                ;;
            gre)
                (( mtu-= 28 ))
                ;;
            *)
                warn $LINENO "Warning: the optimal device MTU is unknown for your tunneling options!"
                mtu="nochange"
                ;;
        esac
    fi
    echo "$mtu"
}

function _neutron_ovs_base_configure_nova_vif_driver {
    local mtu=${Q_GUEST_DEVICE_MTU:-$(_neutron_ovs_device_mtu)}
    if [[ $mtu != "nochange" ]]; then
        # use the same value in both neutron.conf and nova.conf
        iniset $NOVA_CONF DEFAULT network_device_mtu "$mtu"
        iniset $NEUTRON_CONF DEFAULT network_device_mtu "$mtu"
        iniset /$Q_PLUGIN_CONF_FILE agent veth_mtu $((mtu + 4))
    fi
}

# Restore xtrace
$OVSB_XTRACE
