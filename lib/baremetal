#!/usr/bin/env bash
#
# Copyright (c) 2012 Hewlett-Packard Development Company, L.P.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.


# functions to control the configuration and operation of baremetal hypervisor
# in most cases, these should be invoked in the following order:

# before nova-cpu starts:
#  prepare_baremetal_toolchain
#  configure_baremetal_nova_dirs

# after nova and glance have started:
#  build_and_upload_baremetal_deploy_k_and_r $token
#  create_baremetal_flavor $BM_DEPLOY_KERNEL_ID $BM_DEPLOY_RAMDISK_ID
#  upload_baremetal_image $url $token
#  ensure_baremetal_daemons
#  add_baremetal_node <first_mac> <second_mac>

# Dependencies:
# ``VIRT_DRIVER`` must be "baremetal" for any of this to activate


# Save trace setting
XTRACE=$(set +o | grep xtrace)
set +o xtrace

# Defaults
# --------

BM_HOSTNAME=${BM_HOSTNAME:-$(hostname -f)}

BM_DNSMASQ_IFACE=${BM_DNSMASQ_IFACE:-$PUBLIC_INTERFACE}
BM_DNSMASQ_IFACE=${BM_DNSMASQ_IFACE:-eth0}
BM_DNSMASQ_RANGE=${BM_DNSMASQ_RANGE:-192.0.2.41,192.0.2.63}

# these options are only necessary if you test IPMI
PM_ADDR=${PM_ADDR:-0.0.0.0}
PM_USER=${PM_USER:-fake}
PM_PASS=${PM_PASS:-fake}

BM_FLAVOR_CPU=${BM_FLAVOR_CPU:-1}
BM_FLAVOR_RAM=${BM_FLAVOR_RAM:-512}
BM_FLAVOR_ROOT_DISK=${BM_FLAVOR_ROOT_DISK:-0}
BM_FLAVOR_EPHEMERAL_DISK=${BM_FLAVOR_EPHEMERAL_DISK:-0}
BM_FLAVOR_SWAP=${BM_FLAVOR_SWAP:-0}
BM_FLAVOR_NAME=${BM_FLAVOR_NAME:-bm.small}
BM_FLAVOR_ID=${BM_FLAVOR_ID:-11}
BM_FLAVOR_ARCH=${BM_FLAVOR_ARCH:-x86_64}

BM_FIRST_MAC=${BM_FIRST_MAC:-}
BM_SECOND_MAC=${BM_SECOND_MAC:-}

BM_IMAGE_BUILD_DIR=${BM_IMAGE_BUILD_DIR:-$DEST/diskimage-builder}
IMG_PATH=$TOP_DIR/files

KERNEL=$(uname -r)
BM_DEPLOY_RAMDISK=${BM_DEPLOY_RAMDISK:-bm-deploy-$KERNEL-initrd}
BM_DEPLOY_KERNEL=${BM_DEPLOY_KERNEL:-bm-deploy-$KERNEL-vmlinuz}

SHELL_IN_A_BOX_URL=http://shellinabox.googlecode.com/files
SHELL_IN_A_BOX_VER=shellinabox-2.14


# Functions
# ---------

# Check if baremetal is properly enabled
# Returns false if VIRT_DRIVER is not baremetal, or if ENABLED_SERVICES
# does not contain "baremetal"
function is_baremetal() {
   [[ "$ENABLED_SERVICES" =~ 'baremetal' ]] || return 1
   [[ "$VIRT_DRIVER" = 'baremetal' ]] || return 1
   return 0
}

# Install shell-in-a-box
function install_shell_in_a_box() {
   if [[ ! -d $DEST/$SHELL_IN_A_BOX_VER ]]; then
      cd $DEST
      wget $SHELL_IN_A_BOX_URL/$SHELL_IN_A_BOX_VER.tar.gz
      tar xzf $SHELL_IN_A_BOX_VER.tar.gz
   fi
   if [[ ! $(which shellinaboxd) ]]; then
      cd $DEST/$SHELL_IN_A_BOX_VER
      ./configure
      make
      sudo make install
   fi
}

# clone image building toolchain
function prepare_baremetal_toolchain() {
   git_clone $BM_IMAGE_BUILD_REPO $BM_IMAGE_BUILD_DIR $BM_IMAGE_BUILD_BRANCH

   install_shell_in_a_box
}

# prepare various directories needed by baremetal hypervisor
function configure_baremetal_nova_dirs() {
   sudo mkdir -p /tftpboot
   sudo mkdir -p /tftpboot/pxelinux.cfg
   sudo cp /usr/lib/syslinux/pxelinux.0 /tftpboot/
   sudo chown -R stack:libvirtd /tftpboot
   sudo mkdir -p /var/lib/nova/baremetal/console
   sudo mkdir -p /var/lib/nova/baremetal/dnsmasq
   sudo touch /var/lib/nova/baremetal/dnsmasq/dnsmasq-dhcp.host
   sudo chown -R stack:stack /var/lib/nova

   if [[ "$os_PACKAGE" = "deb" ]]; then
       # make sure dnsmasq isn't running after we installed it
       # because baremetal driver will reconfigure and restart this as needed
       sudo /etc/init.d/dnsmasq stop
       sudo update-rc.d dnsmasq disable
   fi
   # TODO(deva): add support on non-deb systems
}

# build deploy kernel+ramdisk, then upload them to glance
# this function sets BM_DEPLOY_KERNEL_ID and BM_DEPLOY_RAMDISK_ID
function upload_baremetal_deploy() {
    token=$1

    if [ ! -e $IMG_PATH/$BM_DEPLOY_KERNEL -a -e /boot/vmlinuz-$KERNEL ]; then
       sudo cp /boot/vmlinuz-$KERNEL $IMG_PATH/$BM_DEPLOY_KERNEL
       sudo chmod a+r $IMG_PATH/$BM_DEPLOY_KERNEL
    fi
    if [ ! -e $IMG_PATH/$BM_DEPLOY_RAMDISK ]; then
       $BM_IMAGE_BUILD_DIR/bin/ramdisk-image-create deploy -o $IMG_PATH/$BM_DEPLOY_RAMDISK -k $KERNEL
    fi

    # load them into glance
    BM_DEPLOY_KERNEL_ID=$(glance image-create \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         --name $BM_DEPLOY_KERNEL \
         --public --disk-format=aki \
         < $IMG_PATH/$BM_DEPLOY_KERNEL  | grep ' id ' | get_field 2)
    BM_DEPLOY_RAMDISK_ID=$(glance image-create \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         --name $BM_DEPLOY_RAMDISK \
         --public --disk-format=ari \
         < $IMG_PATH/$BM_DEPLOY_RAMDISK  | grep ' id ' | get_field 2)
}

# create a basic baremetal flavor, associated with deploy kernel & ramdisk
# Usage: create_baremetal_flavor <aki> <ari>
function create_baremetal_flavor() {
   aki=$1
   ari=$2
   nova flavor-create $BM_FLAVOR_NAME $BM_FLAVOR_ID \
            $BM_FLAVOR_RAM $BM_FLAVOR_ROOT_DISK $BM_FLAVOR_CPU
   nova-manage instance_type set_key \
      --name=$BM_FLAVOR_NAME --key cpu_arch --value $BM_FLAVOR_ARCH
   nova-manage instance_type set_key \
      --name=$BM_FLAVOR_NAME --key deploy_kernel_id --value $aki
   nova-manage instance_type set_key \
      --name=$BM_FLAVOR_NAME --key deploy_ramdisk_id --value $ari
}

# pull run-time kernel/initrd out of disk image and load into glance
# note that $file is currently expected to be in qcow2 format
# Usage: (aki,ari) = extract_and_upload_k_and_r_from_image $token $file
function extract_and_upload_k_and_r_from_image() {
    token=$1
    file=$2
    image_name=$(basename "$file" ".qcow2")

    # this call returns the file names as "$kernel,$ramdisk"
    out=$($BM_IMAGE_BUILD_DIR/bin/disk-image-get-kernel \
            -x -d $IMG_PATH -o bm-deploy -i $file)
    if [ $? -ne 0 ]; then
        die "Failed to get kernel and ramdisk from $file"
    fi
    XTRACE=$(set +o | grep xtrace)
    set +o xtrace
    out=$(echo "$out" | tail -1)
    $XTRACE
    KERNEL=${out%%,*}
    RAMDISK=${out##*,}

    # load them into glance
    KERNEL_ID=$(glance image-create \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         --name $image_name-kernel \
         --public --disk-format=aki \
         < $IMG_PATH/$KERNEL | grep ' id ' | get_field 2)
    RAMDISK_ID=$(glance image-create \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         --name $image_name-initrd \
         --public --disk-format=ari \
         < $IMG_PATH/$RAMDISK | grep ' id ' | get_field 2)
}

function upload_baremetal_image() {
    local image_url=$1
    local token=$2

    # Create a directory for the downloaded image tarballs.
    mkdir -p $FILES/images

    # Downloads the image (uec ami+aki style), then extracts it.
    IMAGE_FNAME=`basename "$image_url"`
    if [[ ! -f $FILES/$IMAGE_FNAME || "$(stat -c "%s" $FILES/$IMAGE_FNAME)" = "0" ]]; then
        wget -c $image_url -O $FILES/$IMAGE_FNAME
        if [[ $? -ne 0 ]]; then
            echo "Not found: $image_url"
            return
        fi
    fi

    KERNEL=""
    RAMDISK=""
    DISK_FORMAT=""
    CONTAINER_FORMAT=""
    UNPACK=""
    case "$IMAGE_FNAME" in
        *.tar.gz|*.tgz)
            # Extract ami and aki files
            [ "${IMAGE_FNAME%.tar.gz}" != "$IMAGE_FNAME" ] &&
                IMAGE_NAME="${IMAGE_FNAME%.tar.gz}" ||
                IMAGE_NAME="${IMAGE_FNAME%.tgz}"
            xdir="$FILES/images/$IMAGE_NAME"
            rm -Rf "$xdir";
            mkdir "$xdir"
            tar -zxf $FILES/$IMAGE_FNAME -C "$xdir"
            KERNEL=$(for f in "$xdir/"*-vmlinuz* "$xdir/"aki-*/image; do
                     [ -f "$f" ] && echo "$f" && break; done; true)
            RAMDISK=$(for f in "$xdir/"*-initrd* "$xdir/"ari-*/image; do
                     [ -f "$f" ] && echo "$f" && break; done; true)
            IMAGE=$(for f in "$xdir/"*.img "$xdir/"ami-*/image; do
                     [ -f "$f" ] && echo "$f" && break; done; true)
            if [[ -z "$IMAGE_NAME" ]]; then
                IMAGE_NAME=$(basename "$IMAGE" ".img")
            fi
            DISK_FORMAT=ami
            CONTAINER_FORMAT=ami
            ;;
        *.qcow2)
            IMAGE="$FILES/${IMAGE_FNAME}"
            IMAGE_NAME=$(basename "$IMAGE" ".qcow2")
            DISK_FORMAT=qcow2
            CONTAINER_FORMAT=bare
            ;;
        *) echo "Do not know what to do with $IMAGE_FNAME"; false;;
    esac

    if [ "$CONTAINER_FORMAT" = "bare" ]; then
        extract_and_upload_k_and_r_from_image $token $IMAGE
    elif [ "$CONTAINER_FORMAT" = "ami" ]; then
        KERNEL_ID=$(glance image-create \
            --os-auth-token $token \
            --os-image-url http://$GLANCE_HOSTPORT \
            --name "$IMAGE_NAME-kernel" --public \
            --container-format aki \
            --disk-format aki < "$KERNEL" | grep ' id ' | get_field 2)
        RAMDISK_ID=$(glance \
           --os-auth-token $token \
           --os-image-url http://$GLANCE_HOSTPORT \
           --name "$IMAGE_NAME-ramdisk" --public \
           --container-format ari \
           --disk-format ari < "$RAMDISK" | grep ' id ' | get_field 2)
    else
       return
    fi

    glance image-create \
       --os-auth-token $token \
       --os-image-url http://$GLANCE_HOSTPORT \
       --name "${IMAGE_NAME%.img}" --public \
       --container-format $CONTAINER_FORMAT \
       --disk-format $DISK_FORMAT \
       ${KERNEL_ID:+--property kernel_id=$KERNEL_ID} \
       ${RAMDISK_ID:+--property ramdisk_id=$RAMDISK_ID} < "${IMAGE}"
}

# ensure dnsmasq and nova-bm-deploy-helper are running
function ensure_baremetal_daemons() {
   # restart dnsmasq
   sudo pkill dnsmasq || true
   sudo dnsmasq --conf-file= --port=0 --enable-tftp --tftp-root=/tftpboot \
      --dhcp-boot=pxelinux.0 --bind-interfaces --pid-file=/var/run/dnsmasq.pid \
      --interface=$BM_DNSMASQ_IFACE --dhcp-range=$BM_DNSMASQ_RANGE

   # ensure callback daemon is running
   [ $(pgrep -f nova-baremetal-deploy-helper) ] || nova-baremetal-deploy-helper &
}

function clear_baremetal_of_all_nodes() {
   list=$(nova-baremetal-manage node list | tail -n +2 | awk '{print $1}' )
   for node in $list
   do
      nova-baremetal-manage node delete $node
   done
   list=$(nova-baremetal-manage interface list | tail -n +2 | awk '{print $1}' )
   for iface in $list
   do
      nova-baremetal-manage interface delete $iface
   done
}

# inform nova-baremetal about nodes, MACs, etc
# Usage: add_baremetal_node <first_mac> <second_mac>
function add_baremetal_node() {
   mac_1=${1:-$BM_FIRST_MAC}
   mac_2=${2:-$BM_SECOND_MAC}

   id=$(nova-baremetal-manage node create \
      --host=$BM_HOSTNAME --prov_mac=$mac_1 \
      --cpus=$BM_FLAVOR_CPU --memory_mb=$BM_FLAVOR_RAM \
      --local_gb=$BM_FLAVOR_ROOT_DISK --terminal_port=0 \
      --pm_address=$PM_ADDR --pm_user=$PM_USER --pm_password=$PM_PASS \
      )
   [ $? -eq 0 ] || [ "$id" ] || die "Error adding baremetal node"
   id2=$(nova-baremetal-manage interface create \
      --node_id=$id --mac_address=$mac_2 --datapath_id=0 --port_no=0 \
      )
   [ $? -eq 0 ] || [ "$id2" ] || die "Error adding interface to barmetal node $id"
}


# Restore xtrace
$XTRACE
