#!/usr/bin/env bash
#
# Copyright (c) 2012 Hewlett-Packard Development Company, L.P.
# All Rights Reserved.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.


# This file provides devstack with the environment and utilities to
# control nova-compute's baremetal driver.
# It sets reasonable defaults to run within a single host,
# using virtual machines in place of physical hardware.
# However, by changing just a few options, devstack+baremetal can in fact
# control physical hardware resources on the same network, if you know
# the MAC address(es) and IPMI credentials.
# 
# At a minimum, to enable the baremetal driver, you must set these in loclarc:
#    VIRT_DRIVER=baremetal
#    ENABLED_SERVICES="$ENABLED_SERVICES,baremetal"
# 
# 
# We utilize a diskimage-building toolchain to create specific images (flavors)
# and push those onto the "baremetal" nodes.
# 
# Below we define various defaults which control the behavior of the
# baremetal compute service, and inform it of the hardware it will contorl.
# 
# Below that, various functions are defined, which are called by devstack
# in the following order:
# 
#  before nova-cpu starts:
#  - prepare_baremetal_toolchain
#  - configure_baremetal_nova_dirs
# 
#  after nova and glance have started:
#  - build_and_upload_baremetal_deploy_k_and_r $token
#  - create_baremetal_flavor $BM_DEPLOY_KERNEL_ID $BM_DEPLOY_RAMDISK_ID
#  - upload_baremetal_image $url $token
#  - add_baremetal_node <first_mac> <second_mac>


# Save trace setting
XTRACE=$(set +o | grep xtrace)
set +o xtrace

# Sub-driver settings
# -------------------

# sub-driver to use for kernel deployment
#  - nova.virt.baremetal.pxe.PXE
#  - nova.virt.baremetal.tilera.TILERA
BM_DRIVER=${BM_DRIVER:-nova.virt.baremetal.pxe.PXE}

# sub-driver to use for remote power management
#  - nova.virt.baremetal.fake.FakePowerManager, for manual power control
#  - nova.virt.baremetal.fake.FakeLibvirtManager, for emulating hw with local vm
#  - nova.virt.baremetal.ipmi.Ipmi, for remote IPMI
#  - nova.virt.baremetal.tilera_pdu.Pdu, for TilePro hardware
BM_POWER_MANAGER=${BM_POWER_MANAGER:-nova.virt.baremetal.fake.FakePowerManager}


# These should be customized to your environment and hardware
# -----------------------------------------------------------

# default hostname is usually fine
BM_HOSTNAME=${BM_HOSTNAME:-$(hostname -f)}

# BM_DNSMASQ_* options must be changed to suit your network environment
BM_DNSMASQ_IFACE=${BM_DNSMASQ_IFACE:-$PUBLIC_INTERFACE}
BM_DNSMASQ_IFACE=${BM_DNSMASQ_IFACE:-eth0}
BM_DNSMASQ_RANGE=${BM_DNSMASQ_RANGE:-192.0.2.41,192.0.2.63}

# BM_FIRST_MAC *must* be set to the MAC address of the node you will boot.
#              This is passed to dnsmasq along with the kernel/ramdisk to
#              deploy via PXE.
BM_FIRST_MAC=${BM_FIRST_MAC:-}

# BM_SECOND_MAC is only important if the host has >1 NIC.
BM_SECOND_MAC=${BM_SECOND_MAC:-}

# Hostname for the baremetal nova-compute node, if not run on this host
BM_HOSTNAME=${BM_HOSTNAME:-$(hostname -f)}

# BM_PM_* options are only necessary if BM_POWER_MANAGER=...IPMI
BM_PM_ADDR=${BM_PM_ADDR:-0.0.0.0}
BM_PM_USER=${BM_PM_USER:-fake}
BM_PM_PASS=${BM_PM_PASS:-fake}

# BM_FLAVOR_* options are arbitrary and not necessarily related to physical
#             hardware capacity. These can be changed if you are testing
#             BaremetalHostManager with multiple nodes and different flavors.
BM_CPU_ARCH=${BM_CPU_ARCH:-x86_64}
BM_FLAVOR_CPU=${BM_FLAVOR_CPU:-1}
BM_FLAVOR_RAM=${BM_FLAVOR_RAM:-512}
BM_FLAVOR_ROOT_DISK=${BM_FLAVOR_ROOT_DISK:-0}
BM_FLAVOR_EPHEMERAL_DISK=${BM_FLAVOR_EPHEMERAL_DISK:-0}
BM_FLAVOR_SWAP=${BM_FLAVOR_SWAP:-0}
BM_FLAVOR_NAME=${BM_FLAVOR_NAME:-bm.small}
BM_FLAVOR_ID=${BM_FLAVOR_ID:-11}
BM_FLAVOR_ARCH=${BM_FLAVOR_ARCH:-$BM_CPU_ARCH}


# Below this, we set some path and filenames.
# Defaults are probably sufficient.
BM_IMAGE_BUILD_DIR=${BM_IMAGE_BUILD_DIR:-$DEST/diskimage-builder}

IMG_PATH=$TOP_DIR/files

KERNEL=$(uname -r)
BM_DEPLOY_RAMDISK=${BM_DEPLOY_RAMDISK:-bm-deploy-$KERNEL-initrd}
BM_DEPLOY_KERNEL=${BM_DEPLOY_KERNEL:-bm-deploy-$KERNEL-vmlinuz}

# If you need to add any extra flavors to the deploy ramdisk image
# eg, specific network drivers, specify them here
BM_DEPLOY_FLAVOR=${BM_DEPLOY_FLAVOR:-}

SHELL_IN_A_BOX_URL=http://shellinabox.googlecode.com/files
SHELL_IN_A_BOX_VER=shellinabox-2.14


# Functions
# ---------

# Check if baremetal is properly enabled
# Returns false if VIRT_DRIVER is not baremetal, or if ENABLED_SERVICES
# does not contain "baremetal"
function is_baremetal() {
   [[ "$ENABLED_SERVICES" =~ 'baremetal' ]] || return 1
   [[ "$VIRT_DRIVER" = 'baremetal' ]] || return 1
   return 0
}

# Install diskimage-builder and shell-in-a-box
# so that we can build the deployment kernel & ramdisk
function prepare_baremetal_toolchain() {
   git_clone $BM_IMAGE_BUILD_REPO $BM_IMAGE_BUILD_DIR $BM_IMAGE_BUILD_BRANCH

   if [[ ! -d $DEST/$SHELL_IN_A_BOX_VER ]]; then
      cd $DEST
      wget $SHELL_IN_A_BOX_URL/$SHELL_IN_A_BOX_VER.tar.gz
      tar xzf $SHELL_IN_A_BOX_VER.tar.gz
   fi
   if [[ ! $(which shellinaboxd) ]]; then
      cd $DEST/$SHELL_IN_A_BOX_VER
      ./configure
      make
      sudo make install
   fi
}

# prepare various directories needed by baremetal hypervisor
function configure_baremetal_nova_dirs() {
   sudo mkdir -p /tftpboot
   sudo mkdir -p /tftpboot/pxelinux.cfg
   sudo cp /usr/lib/syslinux/pxelinux.0 /tftpboot/
   sudo chown -R stack:libvirtd /tftpboot
   sudo mkdir -p /var/lib/nova/baremetal/console
   sudo mkdir -p /var/lib/nova/baremetal/dnsmasq
   sudo touch /var/lib/nova/baremetal/dnsmasq/dnsmasq-dhcp.host
   sudo chown -R stack:stack /var/lib/nova

   if [[ "$os_PACKAGE" = "deb" ]]; then
       # make sure dnsmasq isn't running after we installed it
       # because baremetal driver will reconfigure and restart this as needed
       sudo /etc/init.d/dnsmasq stop
       sudo update-rc.d dnsmasq disable
   fi
   # TODO(deva): add support on non-deb systems
}

# build deploy kernel+ramdisk, then upload them to glance
# this function sets BM_DEPLOY_KERNEL_ID and BM_DEPLOY_RAMDISK_ID
function upload_baremetal_deploy() {
    token=$1

    if [ ! -e $IMG_PATH/$BM_DEPLOY_KERNEL -a -e /boot/vmlinuz-$KERNEL ]; then
       sudo cp /boot/vmlinuz-$KERNEL $IMG_PATH/$BM_DEPLOY_KERNEL
       sudo chmod a+r $IMG_PATH/$BM_DEPLOY_KERNEL
    fi
    if [ ! -e $IMG_PATH/$BM_DEPLOY_RAMDISK ]; then
       $BM_IMAGE_BUILD_DIR/bin/ramdisk-image-create $BM_DEPLOY_FLAVOR deploy -o $IMG_PATH/$BM_DEPLOY_RAMDISK -k $KERNEL
    fi

    # load them into glance
    BM_DEPLOY_KERNEL_ID=$(glance \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         image-create \
         --name $BM_DEPLOY_KERNEL \
         --public --disk-format=aki \
         < $IMG_PATH/$BM_DEPLOY_KERNEL  | grep ' id ' | get_field 2)
    BM_DEPLOY_RAMDISK_ID=$(glance \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         image-create \
         --name $BM_DEPLOY_RAMDISK \
         --public --disk-format=ari \
         < $IMG_PATH/$BM_DEPLOY_RAMDISK  | grep ' id ' | get_field 2)
}

# create a basic baremetal flavor, associated with deploy kernel & ramdisk
# 
# Usage: create_baremetal_flavor <aki_uuid> <ari_uuid>
function create_baremetal_flavor() {
   aki=$1
   ari=$2
   nova flavor-create $BM_FLAVOR_NAME $BM_FLAVOR_ID \
            $BM_FLAVOR_RAM $BM_FLAVOR_ROOT_DISK $BM_FLAVOR_CPU
   nova-manage instance_type set_key \
      --name=$BM_FLAVOR_NAME --key cpu_arch --value $BM_FLAVOR_ARCH
   nova-manage instance_type set_key \
      --name=$BM_FLAVOR_NAME --key deploy_kernel_id --value $aki
   nova-manage instance_type set_key \
      --name=$BM_FLAVOR_NAME --key deploy_ramdisk_id --value $ari
}

# pull run-time kernel/ramdisk out of disk image and load into glance
# note that $file is currently expected to be in qcow2 format
# Sets KERNEL_ID and RAMDISK_ID
# 
# Usage: extract_and_upload_k_and_r_from_image $token $file
function extract_and_upload_k_and_r_from_image() {
    token=$1
    file=$2
    image_name=$(basename "$file" ".qcow2")

    # this call returns the file names as "$kernel,$ramdisk"
    out=$($BM_IMAGE_BUILD_DIR/bin/disk-image-get-kernel \
            -x -d $IMG_PATH -o bm-deploy -i $file)
    if [ $? -ne 0 ]; then
        die "Failed to get kernel and ramdisk from $file"
    fi
    XTRACE=$(set +o | grep xtrace)
    set +o xtrace
    out=$(echo "$out" | tail -1)
    $XTRACE
    KERNEL=${out%%,*}
    RAMDISK=${out##*,}

    # load them into glance
    KERNEL_ID=$(glance \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         image-create \
         --name $image_name-kernel \
         --public --disk-format=aki \
         < $IMG_PATH/$KERNEL | grep ' id ' | get_field 2)
    RAMDISK_ID=$(glance \
         --os-auth-token $token \
         --os-image-url http://$GLANCE_HOSTPORT \
         image-create \
         --name $image_name-initrd \
         --public --disk-format=ari \
         < $IMG_PATH/$RAMDISK | grep ' id ' | get_field 2)
}


# Re-implementation of devstack's "upload_image" function which
# calls extract_and_upload_k_and_r_from_image on the supplied image.
# Takes the same parameters.
# 
# TODO(deva): allow image types besides qcow2 and .tar.gz
function upload_baremetal_image() {
    local image_url=$1
    local token=$2

    # Create a directory for the downloaded image tarballs.
    mkdir -p $FILES/images

    # Downloads the image (uec ami+aki style), then extracts it.
    IMAGE_FNAME=`basename "$image_url"`
    if [[ ! -f $FILES/$IMAGE_FNAME || "$(stat -c "%s" $FILES/$IMAGE_FNAME)" = "0" ]]; then
        wget -c $image_url -O $FILES/$IMAGE_FNAME
        if [[ $? -ne 0 ]]; then
            echo "Not found: $image_url"
            return
        fi
    fi

    KERNEL=""
    RAMDISK=""
    DISK_FORMAT=""
    CONTAINER_FORMAT=""
    UNPACK=""
    case "$IMAGE_FNAME" in
        *.tar.gz|*.tgz)
            # Extract ami and aki files
            [ "${IMAGE_FNAME%.tar.gz}" != "$IMAGE_FNAME" ] &&
                IMAGE_NAME="${IMAGE_FNAME%.tar.gz}" ||
                IMAGE_NAME="${IMAGE_FNAME%.tgz}"
            xdir="$FILES/images/$IMAGE_NAME"
            rm -Rf "$xdir";
            mkdir "$xdir"
            tar -zxf $FILES/$IMAGE_FNAME -C "$xdir"
            KERNEL=$(for f in "$xdir/"*-vmlinuz* "$xdir/"aki-*/image; do
                     [ -f "$f" ] && echo "$f" && break; done; true)
            RAMDISK=$(for f in "$xdir/"*-initrd* "$xdir/"ari-*/image; do
                     [ -f "$f" ] && echo "$f" && break; done; true)
            IMAGE=$(for f in "$xdir/"*.img "$xdir/"ami-*/image; do
                     [ -f "$f" ] && echo "$f" && break; done; true)
            if [[ -z "$IMAGE_NAME" ]]; then
                IMAGE_NAME=$(basename "$IMAGE" ".img")
            fi
            DISK_FORMAT=ami
            CONTAINER_FORMAT=ami
            ;;
        *.qcow2)
            IMAGE="$FILES/${IMAGE_FNAME}"
            IMAGE_NAME=$(basename "$IMAGE" ".qcow2")
            DISK_FORMAT=qcow2
            CONTAINER_FORMAT=bare
            ;;
        *) echo "Do not know what to do with $IMAGE_FNAME"; false;;
    esac

    if [ "$CONTAINER_FORMAT" = "bare" ]; then
        extract_and_upload_k_and_r_from_image $token $IMAGE
    elif [ "$CONTAINER_FORMAT" = "ami" ]; then
        KERNEL_ID=$(glance \
            --os-auth-token $token \
            --os-image-url http://$GLANCE_HOSTPORT \
            image-create \
            --name "$IMAGE_NAME-kernel" --public \
            --container-format aki \
            --disk-format aki < "$KERNEL" | grep ' id ' | get_field 2)
        RAMDISK_ID=$(glance \
            --os-auth-token $token \
            --os-image-url http://$GLANCE_HOSTPORT \
            image-create \
            --name "$IMAGE_NAME-ramdisk" --public \
            --container-format ari \
            --disk-format ari < "$RAMDISK" | grep ' id ' | get_field 2)
    else
       return
    fi

    glance \
       --os-auth-token $token \
       --os-image-url http://$GLANCE_HOSTPORT \
       image-create \
       --name "${IMAGE_NAME%.img}" --public \
       --container-format $CONTAINER_FORMAT \
       --disk-format $DISK_FORMAT \
       ${KERNEL_ID:+--property kernel_id=$KERNEL_ID} \
       ${RAMDISK_ID:+--property ramdisk_id=$RAMDISK_ID} < "${IMAGE}"
}

function clear_baremetal_of_all_nodes() {
   list=$(nova-baremetal-manage node list | tail -n +2 | awk '{print $1}' )
   for node in $list
   do
      nova-baremetal-manage node delete $node
   done
   list=$(nova-baremetal-manage interface list | tail -n +2 | awk '{print $1}' )
   for iface in $list
   do
      nova-baremetal-manage interface delete $iface
   done
}

# inform nova-baremetal about nodes, MACs, etc
# Defaults to using BM_FIRST_MAC and BM_SECOND_MAC if parameters not specified
# 
# Usage: add_baremetal_node <first_mac> <second_mac>
function add_baremetal_node() {
   mac_1=${1:-$BM_FIRST_MAC}
   mac_2=${2:-$BM_SECOND_MAC}

   id=$(nova-baremetal-manage node create \
      --host=$BM_HOSTNAME --prov_mac=$mac_1 \
      --cpus=$BM_FLAVOR_CPU --memory_mb=$BM_FLAVOR_RAM \
      --local_gb=$BM_FLAVOR_ROOT_DISK --terminal_port=0 \
      --pm_address=$BM_PM_ADDR --pm_user=$BM_PM_USER --pm_password=$BM_PM_PASS \
      )
   [ $? -eq 0 ] || [ "$id" ] || die "Error adding baremetal node"
   id2=$(nova-baremetal-manage interface create \
      --node_id=$id --mac_address=$mac_2 --datapath_id=0 --port_no=0 \
      )
   [ $? -eq 0 ] || [ "$id2" ] || die "Error adding interface to barmetal node $id"
}


# Restore xtrace
$XTRACE
